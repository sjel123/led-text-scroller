<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>LED Text Scroller (16√ó64)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: light dark; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Apple Color Emoji", "Segoe UI Emoji", sans-serif;
      margin: 24px; line-height: 1.45;
    }
    h1 { margin: 0 0 8px; }
    .badge { background:#eef2ff; color:#3730a3; padding:4px 8px; border-radius:999px; font-size:12px; font-weight:700; }
    .card {
      border: 1px solid #e5e7eb; border-radius: 16px; padding: 16px; max-width: 980px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.05); background: Canvas; color: CanvasText;
    }
    label { display:block; font-weight:600; margin-top:12px; margin-bottom:6px; }
    input[type="text"], input[type="number"], input[type="color"], select {
      width: 100%; padding: 10px; border: 1px solid #e5e7eb; border-radius: 10px; font-size: 14px;
      background: Field; color: FieldText;
    }
    .row { display:flex; gap:12px; flex-wrap:wrap; }
    .row > div { flex: 1 1 240px; min-width: 220px; }
    .buttons { display:flex; gap:12px; margin-top:16px; flex-wrap: wrap; }
    button {
      border: none; border-radius: 12px; padding: 12px 16px; cursor: pointer; font-weight: 700;
      background: #111827; color: white; box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }
    button.secondary { background: #374151; }
    .hint { color: #6b7280; font-size: 13px; margin-top: 6px; }
    .preview-wrap { display:flex; align-items:center; gap:16px; flex-wrap:wrap; }
    .preview-tools { display:flex; gap:12px; align-items:center; flex-wrap: wrap; }
    .preview-tools label { margin: 0 6px 0 0; font-weight: 600; }
    canvas { image-rendering: pixelated; border-radius: 10px; }
    .subrow { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    .inline { display:flex; align-items:center; gap:8px; }
  </style>
</head>
<body>
  <h1>LED Text Scroller <span class="badge">16√ó64</span></h1>

  <!-- Preview -->
  <div class="card" style="margin-bottom:16px">
    <h3 style="margin:0 0 12px">Preview (local ‚Äî no data sent)</h3>
    <div class="preview-wrap">
      <canvas id="preview" width="64" height="16" style="background:black"></canvas>
      <div class="preview-tools">
        <label for="scale">Scale</label>
        <input id="scale" type="number" min="4" max="40" value="12" style="width:90px" />
        <label><input id="grid" type="checkbox" /> Pixel grid</label>
        <label><input id="crisp" type="checkbox" checked /> Crisp letters</label>
        <label><input id="centerShort" type="checkbox" /> Center when short (scroll)</label>
        <button id="previewPlay">Play</button>
        <button id="previewPause" class="secondary">Pause</button>
        <button id="previewReset" class="secondary">Reset</button>
      </div>
    </div>
    <div class="hint">Crisp = 1-bit edges. Static display is centered. Gradients & emojis preview accurately.</div>
  </div>

  <!-- Controls -->
  <div class="card">
    <label for="text">Text</label>
    <input id="text" type="text" placeholder="Type your message..." value="Hello, world! üåàüöÄ" />

    <div class="subrow" style="margin-top:8px; align-items:center">
      <button id="dailyQuoteBtn" class="secondary" type="button">Use daily quote</button>
      <button id="reloadDailyQuoteBtn" class="secondary" type="button" disabled>Reload daily quote</button>
      <button id="anotherQuoteBtn" class="secondary" type="button">Another quote</button>
      <span id="dailyQuoteStatus" class="hint" aria-live="polite"></span>
    </div>

    <div class="row">
      <div>
        <label for="fontSelect">Font (system)</label>
        <select id="fontSelect">
          {% for name, path in fonts %}
          <option
            value="{{path}}"
            data-fontname="{{name}}"
            {% if "Arial Unicode" in name %}selected{% endif %}
          >{{name}}</option>
          {% endfor %}
        </select>
        <div class="hint">macOS fonts from /System/Library/Fonts, /Library/Fonts, and ~/Library/Fonts.</div>
      </div>
      <div>
        <label for="fontSize">Font size (px)</label>
        <input id="fontSize" type="number" min="6" max="64" value="16" />
      </div>
      <div>
        <label for="emojiBaseline">Emoji baseline offset (px)</label>
        <input id="emojiBaseline" type="number" step="1" value="0" />
        <div class="hint">Positive = move emojis down, Negative = up (only affects lines that contain emoji).</div>
      </div>
      <div>
        <label for="speed">Speed (pixels/sec)</label>
        <input id="speed" type="number" min="1" max="200" value="15" />
      </div>
    </div>

    <div class="row">
      <div>
        <label for="colorMode">Color mode</label>
        <select id="colorMode">
            <option value="solid" selected>Solid</option>
          <option value="gradient">Gradient</option>
        </select>
      </div>
      <div id="solidColorBox">
        <label for="color">Color</label>
        <input id="color" type="color" value="#ffffff" />
      </div>
      <div id="gradientBox" style="display:none">
        <label for="gradientPreset">Gradient preset</label>
        <div class="subrow">
          <select id="gradientPreset">
            <option value="rainbow" selected>Rainbow (HSV)</option>
            <option value="fire">Fire</option>
            <option value="ocean">Ocean</option>
            <option value="sunset">Sunset</option>
            <option value="ice">Ice</option>
          </select>
          <label class="inline"><input id="gradientReverse" type="checkbox" /> Reverse</label>
        </div>
        <div class="subrow">
          <div style="flex:1 1 260px">
            <label for="gradientShift">Gradient shift (px/sec)</label>
            <input id="gradientShift" type="number" step="1" value="0" />
          </div>
        </div>
        <div class="hint">Animate the gradient horizontally.</div>
      </div>

      <div>
        <label for="displayMode">Display</label>
        <select id="displayMode">
          <option value="scroll" selected>Scroll</option>
          <option value="static">Static (no scroll)</option>
        </select>
      </div>
      <div>
        <label for="direction">Direction</label>
        <select id="direction">
          <option value="left" selected>Left ‚Üê</option>
          <option value="right">Right ‚Üí</option>
        </select>
      </div>
      <div>
        <label for="layout">Layouts</label>
        <select id="layout">
          <option value="serpentine">Zig-zag (serpentine)</option>
          <option value="progressive" selected>Progressiv (left‚Üíright each row)</option>
        </select>
        <div class="hint">Affects send order only (wiring). Preview shows the visual frame.</div>
      </div>
      <div>
        <label for="mode">Output mode</label>
        <select id="mode">
          <option value="simple">Simple UDP (7777)</option>
          <option value="ddp" selected>DDP (4048)</option>
          <option value="wled_udp">WLED UDP (21324)</option>
        </select>
      </div>
      <div>
        <label for="ip">Target IP</label>
        <input id="ip" type="text" value="{{ default_ip or '192.168.1.181' }}" />
      </div>
      <div>
        <label for="port">Port</label>
        <input id="port" type="number" value="{{ default_ddp_port or 4048 }}" />
        <div class="hint">Auto-adjusts when you change the mode.</div>
      </div>
      <div>
        <label for="ddpChannel">DDP Channel</label>
        <input id="ddpChannel" type="number" min="1" max="255" value="1" />
        <div class="hint">DDP only.</div>
      </div>
    </div>

    <div class="buttons">
      <button id="startBtn">Start (send)</button>
      <button id="stopBtn" class="secondary">Stop</button>
    </div>
  </div>

  <script>
    const MAT_W = 64, MAT_H = 16;

    function hexToRgb(hex){
      const v = hex.replace("#","");
      return [parseInt(v.slice(0,2),16), parseInt(v.slice(2,4),16), parseInt(v.slice(4,6),16)];
    }
    function clamp01(x){ return Math.max(0, Math.min(1, x)); }
    function hsvToRgb(h, s, v){
      let r=0,g=0,b=0; let i = Math.floor(h*6); let f = h*6 - i;
      let p=v*(1-s), q=v*(1-f*s), t=v*(1-(1-f)*s);
      switch(i%6){ case 0:r=v;g=t;b=p;break; case 1:r=q;g=v;b=p;break; case 2:r=p;g=v;b=t;break;
        case 3:r=p;g=q;b=v;break; case 4:r=t;g=p;b=v;break; case 5:r=v;g=p;b=q;break; }
      return [Math.round(r*255),Math.round(g*255),Math.round(b*255)];
    }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function lerpRgb(a,b,t){ return [Math.round(lerp(a[0],b[0],t)),Math.round(lerp(a[1],b[1],t)),Math.round(lerp(a[2],b[2],t))]; }
    function hasEmoji(s){ try { return /[\p{Extended_Pictographic}]/u.test(s); } catch(e){ return false; } }

    function gradientPresetColor(t,preset){
      t = clamp01(t);
      if(preset === "rainbow") return hsvToRgb(t,1,1);
      const map = {
        fire: {stops:[[0,0,0],[120,0,0],[220,40,0],[255,140,0],[255,220,0],[255,255,255]], pos:[0,0.15,0.35,0.60,0.85,1]},
        ocean:{stops:[[0,10,40],[0,90,160],[0,180,255],[120,220,255]],pos:[0,0.4,0.8,1]},
        sunset:{stops:[[120,0,80],[200,40,0],[255,120,0],[255,220,120]],pos:[0,0.35,0.7,1]},
        ice:{stops:[[255,255,255],[200,240,255],[160,220,255],[120,200,255],[80,180,255]],pos:[0,0.25,0.5,0.75,1]}
      };
      const g = map[preset]; if(!g) return [255,255,255];
      for(let i=0;i<g.pos.length-1;i++){
        if(t>=g.pos[i] && t<=g.pos[i+1]){ const lt=(t-g.pos[i])/(g.pos[i+1]-g.pos[i]); return lerpRgb(g.stops[i],g.stops[i+1],lt); }
      }
      return g.stops[g.stops.length-1];
    }

    function updateColorModeUI(){
      const isGrad = document.getElementById("colorMode").value === "gradient";
      document.getElementById("solidColorBox").style.display = isGrad ? "none" : "";
      document.getElementById("gradientBox").style.display = isGrad ? "" : "none";
    }

    function updatePortHelper(){
      const modeSel = document.getElementById("mode")
      const portInput = document.getElementById("port")
      const mode = modeSel.value
      if(mode === "simple" && (!portInput.value || ["4048","21324"].includes(portInput.value))) portInput.value = "7777";
      if(mode === "ddp" && (!portInput.value || ["7777","21324"].includes(portInput.value)))  portInput.value = "{{ default_ddp_port or 4048 }}";
      if(mode === "wled_udp" && (!portInput.value || ["7777","4048"].includes(portInput.value))) portInput.value = "21324";
    }

    function updateDisplayModeUI(){
      const disp = document.getElementById("displayMode").value
      const speed = document.getElementById("speed")
      const direction = document.getElementById("direction")
      const isStatic = (disp === "static")
      speed.disabled = isStatic
      direction.disabled = isStatic
    }

    // ---------- preview engine ----------
    const cvs = document.getElementById("preview")
    const ctx = cvs.getContext("2d", { alpha: false })
    ctx.imageSmoothingEnabled = false

    const scaleInput = document.getElementById("scale")
    const gridInput = document.getElementById("grid")
    const crispInput = document.getElementById("crisp")
    const centerShortInput = document.getElementById("centerShort")
    const textInput = document.getElementById("text")
    const dailyQuoteBtn = document.getElementById("dailyQuoteBtn")
    const reloadDailyQuoteBtn = document.getElementById("reloadDailyQuoteBtn")
    const anotherQuoteBtn = document.getElementById("anotherQuoteBtn")
    const dailyQuoteStatus = document.getElementById("dailyQuoteStatus")
    let lastDailyQuote = null

    const colorModeInput = document.getElementById("colorMode")
    const solidColorInput = document.getElementById("color")
    const gradientPresetInput = document.getElementById("gradientPreset")
    const gradientReverseInput = document.getElementById("gradientReverse")
    const gradientShiftInput = document.getElementById("gradientShift")

    const emojiBaselineInput = document.getElementById("emojiBaseline")

    const previewPlayBtn = document.getElementById("previewPlay")
    const previewPauseBtn = document.getElementById("previewPause")
    const previewResetBtn = document.getElementById("previewReset")

    let animReq = null, shift = 0, maxShift = 0, lastTs = 0, gradShift = 0

    function currentFontCSS(){
      const sel = document.getElementById("fontSelect")
      const opt = sel.options[sel.selectedIndex]
      const name = opt ? (opt.getAttribute("data-fontname") || "sans-serif") : "sans-serif"
      const size = parseInt(document.getElementById("fontSize").value,10) || 16
      return `${size}px "${name}", "Apple Color Emoji", "Segoe UI Emoji", emoji, sans-serif`
    }
    function measureTextWidth(text, fontCSS){
      ctx.save(); ctx.font = fontCSS; const w = ctx.measureText(text).width; ctx.restore(); return Math.max(0, Math.floor(w))
    }
    function applyScale(){
      const s = Math.max(4, Math.min(40, parseInt(scaleInput.value,10)||12))
      cvs.style.width = (MAT_W * s) + "px"
      cvs.style.height = (MAT_H * s) + "px"
    }
    function drawGrid(){
      ctx.save(); ctx.strokeStyle = "rgba(255,255,255,0.08)"; ctx.lineWidth = 1
      for(let x=1; x<MAT_W; x++){ ctx.beginPath(); ctx.moveTo(x+0.5, 0); ctx.lineTo(x+0.5, MAT_H); ctx.stroke() }
      for(let y=1; y<MAT_H; y++){ ctx.beginPath(); ctx.moveTo(0, y+0.5); ctx.lineTo(MAT_W, y+0.5); ctx.stroke() }
      ctx.restore()
    }

    function recolorWithGradient(ctx, w, h, preset, reversed, shiftPx){
      const img = ctx.getImageData(0,0,w,h)
      const d = img.data, period = w
      for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
          const i = (y*w + x)*4
          const lum = (d[i]*0.2126 + d[i+1]*0.7152 + d[i+2]*0.0722)
          if(lum >= 128){
            let xx = (x + Math.floor(shiftPx)) % period; if(xx < 0) xx += period
            let t = xx / (period - 1 || 1); if(reversed) t = 1 - t
            const [r,g,b] = gradientPresetColor(t, preset)
            d[i]=r; d[i+1]=g; d[i+2]=b; d[i+3]=255
          } else {
            d[i]=0; d[i+1]=0; d[i+2]=0; d[i+3]=255
          }
        }
      }
      ctx.putImageData(img,0,0)
    }
    function thresholdAndRecolor(ctx, w, h, hexColor){
      const [rC,gC,bC] = hexToRgb(hexColor)
      const img = ctx.getImageData(0,0,w,h), d = img.data
      for(let i=0;i<d.length;i+=4){
        const lum = (d[i]*0.2126 + d[i+1]*0.7152 + d[i+2]*0.0722)
        if(lum >= 128){ d[i]=rC; d[i+1]=gC; d[i+2]=bC; d[i+3]=255 } else { d[i]=0; d[i+1]=0; d[i+2]=0; d[i+3]=255 }
      }
      ctx.putImageData(img,0,0)
    }

    function recalcPreview(){
      shift = 0; gradShift = 0; lastTs = 0
      const text = document.getElementById("text").value
      const fontCSS = currentFontCSS()
      const textW = measureTextWidth(text, fontCSS)
      const disp = document.getElementById("displayMode").value
      maxShift = (disp === "static") ? 0 : (MAT_W + textW)
      applyScale(); drawFrame(0)
    }

    function drawFrame(shiftPx){
      ctx.save(); ctx.imageSmoothingEnabled = false
      ctx.fillStyle="black"; ctx.fillRect(0,0,MAT_W,MAT_H)

      const text = document.getElementById("text").value
      const dir = document.getElementById("direction").value
      const disp = document.getElementById("displayMode").value
      const fontCSS = currentFontCSS()
      const size = parseInt(document.getElementById("fontSize").value,10) || 16
      const isCrisp = !!crispInput.checked
      const isGradient = (colorModeInput.value === "gradient")
      const preset = gradientPresetInput.value
      const reversed = !!gradientReverseInput.checked
      const solidHex = solidColorInput.value
      const emojiOffset = parseInt(emojiBaselineInput.value, 10) || 0
      const emojiPresent = hasEmoji(text)

      ctx.font = fontCSS; ctx.textBaseline = "alphabetic"
      const metrics = ctx.measureText(text)
      const ascent  = metrics.actualBoundingBoxAscent || (size * 0.8)
      const descent = metrics.actualBoundingBoxDescent || (size * 0.2)
      const textH   = Math.ceil(ascent + descent)
      let baselineY = Math.floor((MAT_H - textH) / 2 + ascent)
      if (emojiPresent) baselineY += emojiOffset

      const textW = measureTextWidth(text, fontCSS)
      const centerX = Math.floor((MAT_W - textW)/2)

      if (disp === "static") {
        const x = centerX
        ctx.fillStyle = "#ffffff"; ctx.fillText(text, x, baselineY)
        if(isGradient){ recolorWithGradient(ctx, MAT_W, MAT_H, preset, reversed, gradShift) }
        else if(isCrisp){ thresholdAndRecolor(ctx, MAT_W, MAT_H, solidHex) }
      } else {
        const sPx = Math.floor(shiftPx)
        const useCenterShort = !!centerShortInput.checked && (textW < MAT_W)
        ctx.fillStyle = "#ffffff"
        if(useCenterShort){
          const delta = (dir === "left" ? -sPx : sPx)
          ctx.save(); ctx.beginPath(); ctx.rect(0,0,MAT_W,MAT_H); ctx.clip()
          ctx.fillText(text, centerX + delta, baselineY)
          ctx.restore()
        } else {
          if(dir === "left"){
            ctx.save(); ctx.beginPath(); ctx.rect(0,0,MAT_W,MAT_H); ctx.clip()
            ctx.translate(-sPx,0); ctx.fillText(text, MAT_W, baselineY); ctx.restore()
          } else {
            const canvasW = Math.max(MAT_W, textW + MAT_W)
            ctx.save(); ctx.beginPath(); ctx.rect(0,0,MAT_W,MAT_H); ctx.clip()
            ctx.translate(canvasW - MAT_W - sPx, 0); ctx.fillText(text, 0, baselineY); ctx.restore()
          }
        }
        if(isGradient){ recolorWithGradient(ctx, MAT_W, MAT_H, preset, reversed, gradShift) }
        else if(isCrisp){ thresholdAndRecolor(ctx, MAT_W, MAT_H, solidHex) }
      }

      if(gridInput.checked) drawGrid()
      ctx.restore()
    }

    function animatePreview(ts){
      const disp = document.getElementById("displayMode").value
      if(!lastTs) lastTs = ts
      const dt = (ts - lastTs) / 1000.0; lastTs = ts

      if (disp === "scroll") {
        const speed = Math.max(1, parseFloat(document.getElementById("speed").value)||40)
        shift += speed * dt; if(shift >= maxShift) shift = 0
      }
      const gspd = parseFloat(gradientShiftInput.value)||0
      gradShift = (gradShift + gspd * dt) % MAT_W

      drawFrame(shift)
      animReq = requestAnimationFrame(animatePreview)
    }

    // UI bindings
    document.getElementById("previewPlay").addEventListener("click", () => { if(animReq) return; recalcPreview(); animReq = requestAnimationFrame(animatePreview) })
    document.getElementById("previewPause").addEventListener("click", () => { if(animReq){ cancelAnimationFrame(animReq); animReq=null } })
    document.getElementById("previewReset").addEventListener("click", () => { if(animReq){ cancelAnimationFrame(animReq); animReq=null } recalcPreview() })

    ;["text","fontSelect","fontSize","speed","direction","crisp","displayMode","centerShort","colorMode","color","gradientPreset","gradientReverse","gradientShift","emojiBaseline"].forEach(id => {
      const el = document.getElementById(id)
      el.addEventListener("change", () => { if(id==="colorMode") updateColorModeUI(); if(!animReq) recalcPreview(); })
      el.addEventListener("input",  () => { if(!animReq) recalcPreview() })
    })
    document.getElementById("mode").addEventListener("change", updatePortHelper)

    function nudgeToScrollIfStatic(){ const sel=document.getElementById("displayMode"); if (sel.value==="static"){ sel.value="scroll"; updateDisplayModeUI(); if(!animReq) recalcPreview(); } }
    document.getElementById("speed").addEventListener("input", nudgeToScrollIfStatic)
    document.getElementById("speed").addEventListener("change", nudgeToScrollIfStatic)
    document.getElementById("direction").addEventListener("change", nudgeToScrollIfStatic)

    document.getElementById("startBtn").addEventListener("click", async () => {
      if(!animReq){ recalcPreview(); animReq = requestAnimationFrame(animatePreview) }
      const body = {
        text: document.getElementById("text").value,
        font_path: document.getElementById("fontSelect").value,
        font_size: parseInt(document.getElementById("fontSize").value, 10),

        color_mode: document.getElementById("colorMode").value,
        color: hexToRgb(document.getElementById("color").value),
        gradient_preset: document.getElementById("gradientPreset").value,
        gradient_reverse: !!document.getElementById("gradientReverse").checked,
        gradient_shift_speed: parseFloat(document.getElementById("gradientShift").value)||0,

        speed: parseFloat(document.getElementById("speed").value),
        direction: document.getElementById("direction").value,
        serpentine: document.getElementById("layout").value === "serpentine",
        mode: document.getElementById("mode").value,
        ip: document.getElementById("ip").value,
        port: parseInt(document.getElementById("port").value, 10),
        ddp_channel: parseInt(document.getElementById("ddpChannel").value, 10),
        crisp: !!document.getElementById("crisp").checked,
        display_mode: document.getElementById("displayMode").value,
        center_short: !!document.getElementById("centerShort").checked,

        emoji_baseline_offset: parseInt(document.getElementById("emojiBaseline").value,10) || 0
      }

      try {
        const r = await fetch("/start", { method:"POST", headers: {"Content-Type":"application/json"}, body: JSON.stringify(body) })
        const j = await r.json()
        if(!j.ok){ alert(j.error || "Failed to start"); }
      } catch (e){ alert("Failed to reach server: " + e) }
    })
    document.getElementById("stopBtn").addEventListener("click", async () => { try { await fetch("/stop",{method:"POST"}) } catch(e){} })

    async function requestQuote(variant, loadingText) {
      dailyQuoteStatus.textContent = loadingText
      const btns = [dailyQuoteBtn, anotherQuoteBtn]
      if(reloadDailyQuoteBtn) btns.push(reloadDailyQuoteBtn)
      btns.forEach(btn => { if(btn) btn.disabled = true })
      try {
        const url = variant ? `/daily-quote?variant=${variant}` : "/daily-quote"
        const res = await fetch(url)
        if(!res.ok) throw new Error("Quote service unavailable")
        const data = await res.json()
        if(!data.ok) throw new Error(data.error || "Quote service error")
        textInput.value = data.quote
        if(!animReq) recalcPreview()
        if(!variant) {
          lastDailyQuote = data.quote
          if(reloadDailyQuoteBtn) reloadDailyQuoteBtn.disabled = false
        }
        dailyQuoteStatus.textContent = variant ? "Quote loaded" : "Daily quote loaded"
      } catch (err) {
        const message = err && err.message ? err.message : "Failed to load quote"
        dailyQuoteStatus.textContent = message
      } finally {
        btns.forEach(btn => { if(btn) btn.disabled = false })
        setTimeout(() => {
          const current = dailyQuoteStatus.textContent
          if(current === (variant ? "Quote loaded" : "Daily quote loaded") || current === loadingText) {
            dailyQuoteStatus.textContent = ""
          }
        }, 3000)
      }
    }

    dailyQuoteBtn.addEventListener("click", () => requestQuote("", "Fetching daily quote..."))
    anotherQuoteBtn.addEventListener("click", () => requestQuote("alternate", "Fetching alternate quote..."))
    reloadDailyQuoteBtn.addEventListener("click", () => {
      if(lastDailyQuote) {
        textInput.value = lastDailyQuote
        if(!animReq) recalcPreview()
        dailyQuoteStatus.textContent = "Daily quote loaded"
        setTimeout(() => { if(dailyQuoteStatus.textContent === "Daily quote loaded") dailyQuoteStatus.textContent = "" }, 3000)
        return
      }
      requestQuote("", "Fetching daily quote...")
    })

    // init
    updatePortHelper(); updateDisplayModeUI(); updateColorModeUI();
    (function ensureArialUnicodeDefault(){
      const sel = document.getElementById("fontSelect"); if (!sel) return;
      const hasSelected = Array.from(sel.options).some(o => o.selected); if (hasSelected) return;
      const target = Array.from(sel.options).find(o => (o.getAttribute("data-fontname") || "").toLowerCase().includes("arial unicode"));
      if (target) target.selected = true;
    })();
    recalcPreview()
  </script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>LED Text Scroller (16√ó64)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      color-scheme: light dark;
      --bg: #f3f4f6;
      --bg-alt: #e5e7eb;
      --card-bg: Canvas;
      --card-border: #e5e7eb;
      --card-shadow: 0 10px 30px rgba(15, 23, 42, 0.12);
      --text: CanvasText;
      --muted: #6b7280;
      --primary: #111827;
      --primary-soft: #e5e7ff;
      --accent: #3730a3;
      --accent-soft: #eef2ff;
      --secondary: #374151;
      --radius-xl: 16px;
      --radius-md: 10px;
      --spacing: 16px;
      --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
        "Apple Color Emoji", "Segoe UI Emoji", sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 24px;
      font-family: var(--font-sans);
      line-height: 1.45;
      background:
        radial-gradient(circle at top left, #e0f2fe 0, transparent 55%),
        radial-gradient(circle at top right, #e5e7ff 0, transparent 60%),
        var(--bg);
      color: var(--text);
    }

    .page {
      max-width: 1040px;
      margin: 0 auto;
    }

    header.page-header {
      margin-bottom: 20px;
    }

    h1 {
      margin: 0 0 4px;
      font-size: 1.6rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .badge {
      background: var(--accent-soft);
      color: var(--accent);
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .subtitle {
      font-size: 0.9rem;
      color: var(--muted);
    }

    .layout-stack {
      display: flex;
      flex-direction: column;
      gap: 16px;
      margin-top: 16px;
    }

    .card {
      border: 1px solid var(--card-border);
      border-radius: var(--radius-xl);
      padding: 16px;
      background: var(--card-bg);
      box-shadow: var(--card-shadow);
    }

    .card-header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 0.75rem;
      margin-bottom: 10px;
    }

    .card-title {
      font-size: 1rem;
      font-weight: 600;
      margin: 0;
    }

    .card-subtitle {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .section-label {
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-weight: 600;
      color: var(--muted);
      margin: 16px 0 6px;
    }

    label {
      display: block;
      font-weight: 600;
      margin-top: 10px;
      margin-bottom: 4px;
      font-size: 0.86rem;
    }

    input[type="text"],
    input[type="number"],
    input[type="color"],
    select {
      width: 100%;
      padding: 8px 10px;
      border: 1px solid #d1d5db;
      border-radius: var(--radius-md);
      font-size: 14px;
      background: Field;
      color: FieldText;
    }

    input[type="text"]:focus,
    input[type="number"]:focus,
    input[type="color"]:focus,
    select:focus,
    button:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(55, 48, 163, 0.4);
    }

    .row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 4px;
    }

    .row > div {
      flex: 1 1 220px;
      min-width: 200px;
    }

    .subrow {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    .inline {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.8rem;
    }

    .hint {
      color: var(--muted);
      font-size: 0.78rem;
      margin-top: 4px;
    }

    .hint code {
      font-size: 0.78rem;
    }

    .preview-shell {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: flex-start;
    }

    .preview-display {
      flex: 0 0 auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: center;
    }

    canvas {
      image-rendering: pixelated;
      border-radius: 10px;
      background: black;
      border: 1px solid #020617;
    }

    .preview-tools {
      display: flex;
      flex-wrap: wrap;
      gap: 8px 12px;
      align-items: center;
      font-size: 0.8rem;
    }

    .preview-tools label {
      margin: 0;
      font-weight: 600;
      font-size: 0.8rem;
    }

    #scale {
      width: 80px;
    }

    .buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 16px;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 10px 16px;
      cursor: pointer;
      font-weight: 700;
      font-size: 0.86rem;
      background: var(--primary);
      color: white;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.18);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: transform 0.05s ease, box-shadow 0.1s ease, filter 0.1s ease;
    }

    button.secondary {
      background: var(--secondary);
    }

    button:active {
      transform: translateY(1px);
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }

    button:hover {
      filter: brightness(0.97);
    }

    /* Fine-grained layout tiers for the control card */
    .control-section {
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(249, 250, 251, 0.8);
      border: 1px solid rgba(209, 213, 219, 0.7);
      margin-top: 8px;
    }

    .control-section + .control-section {
      margin-top: 10px;
    }

    /* Responsive tweaks */
    @media (max-width: 900px) {
      body {
        padding: 16px;
      }
      .card {
        padding: 14px;
      }
    }

    @media (max-width: 640px) {
      header.page-header {
        text-align: left;
      }
      h1 {
        flex-wrap: wrap;
        font-size: 1.4rem;
      }
      .preview-shell {
        flex-direction: column;
      }
      .preview-display {
        align-items: flex-start;
      }
    }
  </style>
</head>
<body>
  <main class="page">
    <header class="page-header">
      <h1>
        LED Text Scroller
        <span class="badge">16√ó64</span>
      </h1>
      <p class="subtitle">
        Design and preview scrolling or static text for your 16√ó64 LED matrix, then stream frames to your target device.
      </p>
    </header>

    <div class="layout-stack">
      <!-- Preview card -->
      <section class="card" aria-labelledby="preview-title">
        <div class="card-header">
          <div>
            <h2 id="preview-title" class="card-title">Preview (local only)</h2>
            <p class="card-subtitle">
              This preview runs entirely in the browser. No data is sent until you press <strong>Start (send)</strong>.
            </p>
          </div>
        </div>

        <div class="preview-shell">
          <div class="preview-display">
            <canvas id="preview" width="64" height="16"></canvas>
            <div class="hint">
              Crisp uses 1-bit edges for sharp text. Gradients & emojis are rendered accurately in the preview.
            </div>
          </div>

          <div class="preview-tools">
            <label for="scale">Scale</label>
            <input id="scale" type="number" min="4" max="40" value="12" />

            <label class="inline">
              <input id="grid" type="checkbox" />
              Pixel grid
            </label>

            <label class="inline">
              <input id="crisp" type="checkbox" checked />
              Crisp letters
            </label>

            <label class="inline">
              <input id="centerShort" type="checkbox" />
              Center short text (scroll)
            </label>

            <button id="previewPlay" type="button">Play</button>
            <button id="previewPause" type="button" class="secondary">Pause</button>
            <button id="previewReset" type="button" class="secondary">Reset</button>
          </div>
        </div>
      </section>

      <!-- Controls card -->
      <section class="card" aria-labelledby="controls-title">
        <div class="card-header">
          <div>
            <h2 id="controls-title" class="card-title">Message & Output Settings</h2>
            <p class="card-subtitle">
              Configure your message, styling, motion, and output target, then send frames to your LED setup.
            </p>
          </div>
        </div>

        <!-- Message & quotes -->
        <div class="control-section">
          <div class="section-label">Message</div>

          <label for="text">Text</label>
          <input
            id="text"
            type="text"
            placeholder="Type your message..."
            value="Hello, world! üåàüöÄ"
          />

          <div class="subrow" style="margin-top: 6px;">
            <button id="dailyQuoteBtn" class="secondary" type="button">
              Use daily quote
            </button>
            <button id="reloadDailyQuoteBtn" class="secondary" type="button" disabled>
              Reload daily quote
            </button>
            <button id="anotherQuoteBtn" class="secondary" type="button">
              Another quote
            </button>
            <span id="dailyQuoteStatus" class="hint" aria-live="polite"></span>
          </div>
        </div>

        <!-- Typography & layout -->
        <div class="control-section">
          <div class="section-label">Typography & Layout</div>

          <div class="row">
            <div>
              <label for="fontSelect">Font (system)</label>
              <select id="fontSelect">
                {% for name, path in fonts %}
                <option
                  value="{{path}}"
                  data-fontname="{{name}}"
                  {% if "Arial Unicode" in name %}selected{% endif %}
                >
                  {{name}}
                </option>
                {% endfor %}
              </select>
              <div class="hint">
                macOS fonts from /System/Library/Fonts, /Library/Fonts, and ~/Library/Fonts.
              </div>
            </div>

            <div>
              <label for="fontSize">Font size (px)</label>
              <input id="fontSize" type="number" min="6" max="64" value="16" />
            </div>

            <div>
              <label for="emojiBaseline">Emoji baseline offset (px)</label>
              <input id="emojiBaseline" type="number" step="1" value="0" />
              <div class="hint">
                Positive moves emoji down, negative moves them up (only lines containing emoji).
              </div>
            </div>

            <div>
              <label for="speed">Speed (pixels/sec)</label>
              <input id="speed" type="number" min="1" max="200" value="15" />
            </div>
          </div>
        </div>

        <!-- Color & effects -->
        <div class="control-section">
          <div class="section-label">Color & Effects</div>

          <div class="row">
            <div>
              <label for="colorMode">Color mode</label>
              <select id="colorMode">
                <option value="solid" selected>Solid</option>
                <option value="gradient">Gradient</option>
              </select>
            </div>

            <div id="solidColorBox">
              <label for="color">Color</label>
              <input id="color" type="color" value="#ffffff" />
            </div>

            <div id="gradientBox" style="display:none">
              <label for="gradientPreset">Gradient preset</label>
              <div class="subrow">
                <select id="gradientPreset">
                  <option value="rainbow" selected>Rainbow (HSV)</option>
                  <option value="fire">Fire</option>
                  <option value="ocean">Ocean</option>
                  <option value="sunset">Sunset</option>
                  <option value="ice">Ice</option>
                </select>
                <label class="inline">
                  <input id="gradientReverse" type="checkbox" />
                  Reverse
                </label>
              </div>

              <div class="subrow">
                <div style="flex:1 1 260px">
                  <label for="gradientShift">Gradient shift (px/sec)</label>
                  <input id="gradientShift" type="number" step="1" value="0" />
                </div>
              </div>
              <div class="hint">
                Animate the gradient horizontally across the text.
              </div>
            </div>
          </div>
        </div>

        <!-- Motion & display -->
        <div class="control-section">
          <div class="section-label">Motion & Display</div>

          <div class="row">
            <div>
              <label for="displayMode">Display</label>
              <select id="displayMode">
                <option value="scroll" selected>Scroll</option>
                <option value="static">Static (no scroll)</option>
              </select>
            </div>

            <div>
              <label for="direction">Direction</label>
              <select id="direction">
                <option value="left" selected>Left ‚Üê</option>
                <option value="right">Right ‚Üí</option>
              </select>
            </div>

            <div>
              <label for="layout">Layout</label>
              <select id="layout">
                <option value="serpentine">Zig-zag (serpentine)</option>
                <option value="progressive" selected>Progressive (left‚Üíright each row)</option>
              </select>
              <div class="hint">
                Affects the send order/wiring only. Preview always shows the visual frame.
              </div>
            </div>
          </div>
        </div>

        <!-- Output target -->
        <div class="control-section">
          <div class="section-label">Output Target</div>

          <div class="row">
            <div>
              <label for="mode">Output mode</label>
              <select id="mode">
                <option value="simple">Simple UDP (7777)</option>
                <option value="ddp" selected>DDP (4048)</option>
                <option value="wled_udp">WLED UDP (21324)</option>
              </select>
            </div>

            <div>
              <label for="ip">Target IP</label>
              <input
                id="ip"
                type="text"
                value="{{ default_ip or '192.168.1.181' }}"
              />
            </div>

            <div>
              <label for="port">Port</label>
              <input
                id="port"
                type="number"
                value="{{ default_ddp_port or 4048 }}"
              />
              <div class="hint">
                This auto-adjusts when you change the output mode.
              </div>
            </div>

            <div>
              <label for="ddpChannel">DDP Channel</label>
              <input id="ddpChannel" type="number" min="1" max="255" value="1" />
              <div class="hint">DDP only.</div>
            </div>
          </div>
        </div>

        <!-- Start / Stop -->
        <div class="buttons">
          <button id="startBtn" type="button">
            Start (send)
          </button>
          <button id="stopBtn" type="button" class="secondary">
            Stop
          </button>
        </div>
      </section>
    </div>
  </main>

  <script>
    const MAT_W = 64, MAT_H = 16;

    function hexToRgb(hex){
      const v = hex.replace("#","");
      return [parseInt(v.slice(0,2),16), parseInt(v.slice(2,4),16), parseInt(v.slice(4,6),16)];
    }
    function clamp01(x){ return Math.max(0, Math.min(1, x)); }
    function hsvToRgb(h, s, v){
      let r=0,g=0,b=0; let i = Math.floor(h*6); let f = h*6 - i;
      let p=v*(1-s), q=v*(1-f*s), t=v*(1-(1-f)*s);
      switch(i%6){ case 0:r=v;g=t;b=p;break; case 1:r=q;g=v;b=p;break; case 2:r=p;g=v;b=t;break;
        case 3:r=p;g=q;b=v;break; case 4:r=t;g=p;b=v;break; case 5:r=v;g=p;b=q;break; }
      return [Math.round(r*255),Math.round(g*255),Math.round(b*255)];
    }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function lerpRgb(a,b,t){ return [Math.round(lerp(a[0],b[0],t)),Math.round(lerp(a[1],b[1],t)),Math.round(lerp(a[2],b[2],t))]; }
    function hasEmoji(s){ try { return /[\p{Extended_Pictographic}]/u.test(s); } catch(e){ return false; } }

    function gradientPresetColor(t,preset){
      t = clamp01(t);
      if(preset === "rainbow") return hsvToRgb(t,1,1);
      const map = {
        fire: {stops:[[0,0,0],[120,0,0],[220,40,0],[255,140,0],[255,220,0],[255,255,255]], pos:[0,0.15,0.35,0.60,0.85,1]},
        ocean:{stops:[[0,10,40],[0,90,160],[0,180,255],[120,220,255]],pos:[0,0.4,0.8,1]},
        sunset:{stops:[[120,0,80],[200,40,0],[255,120,0],[255,220,120]],pos:[0,0.35,0.7,1]},
        ice:{stops:[[255,255,255],[200,240,255],[160,220,255],[120,200,255],[80,180,255]],pos:[0,0.25,0.5,0.75,1]}
      };
      const g = map[preset]; if(!g) return [255,255,255];
      for(let i=0;i<g.pos.length-1;i++){
        if(t>=g.pos[i] && t<=g.pos[i+1]){ const lt=(t-g.pos[i])/(g.pos[i+1]-g.pos[i]); return lerpRgb(g.stops[i],g.stops[i+1],lt); }
      }
      return g.stops[g.stops.length-1];
    }

    function updateColorModeUI(){
      const isGrad = document.getElementById("colorMode").value === "gradient";
      document.getElementById("solidColorBox").style.display = isGrad ? "none" : "";
      document.getElementById("gradientBox").style.display = isGrad ? "" : "none";
    }

    function updatePortHelper(){
      const modeSel = document.getElementById("mode")
      const portInput = document.getElementById("port")
      const mode = modeSel.value
      if(mode === "simple" && (!portInput.value || ["4048","21324"].includes(portInput.value))) portInput.value = "7777";
      if(mode === "ddp" && (!portInput.value || ["7777","21324"].includes(portInput.value)))  portInput.value = "{{ default_ddp_port or 4048 }}";
      if(mode === "wled_udp" && (!portInput.value || ["7777","4048"].includes(portInput.value))) portInput.value = "21324";
    }

    function updateDisplayModeUI(){
      const disp = document.getElementById("displayMode").value
      const speed = document.getElementById("speed")
      const direction = document.getElementById("direction")
      const isStatic = (disp === "static")
      speed.disabled = isStatic
      direction.disabled = isStatic
    }

    // ---------- preview engine ----------
    const cvs = document.getElementById("preview")
    const ctx = cvs.getContext("2d", { alpha: false })
    ctx.imageSmoothingEnabled = false

    const scaleInput = document.getElementById("scale")
    const gridInput = document.getElementById("grid")
    const crispInput = document.getElementById("crisp")
    const centerShortInput = document.getElementById("centerShort")
    const textInput = document.getElementById("text")
    const dailyQuoteBtn = document.getElementById("dailyQuoteBtn")
    const reloadDailyQuoteBtn = document.getElementById("reloadDailyQuoteBtn")
    const anotherQuoteBtn = document.getElementById("anotherQuoteBtn")
    const dailyQuoteStatus = document.getElementById("dailyQuoteStatus")
    let lastDailyQuote = null

    const colorModeInput = document.getElementById("colorMode")
    const solidColorInput = document.getElementById("color")
    const gradientPresetInput = document.getElementById("gradientPreset")
    const gradientReverseInput = document.getElementById("gradientReverse")
    const gradientShiftInput = document.getElementById("gradientShift")

    const emojiBaselineInput = document.getElementById("emojiBaseline")

    const previewPlayBtn = document.getElementById("previewPlay")
    const previewPauseBtn = document.getElementById("previewPause")
    const previewResetBtn = document.getElementById("previewReset")

    let animReq = null, shift = 0, maxShift = 0, lastTs = 0, gradShift = 0

    function currentFontCSS(){
      const sel = document.getElementById("fontSelect")
      const opt = sel.options[sel.selectedIndex]
      const name = opt ? (opt.getAttribute("data-fontname") || "sans-serif") : "sans-serif"
      const size = parseInt(document.getElementById("fontSize").value,10) || 16
      return `${size}px "${name}", "Apple Color Emoji", "Segoe UI Emoji", emoji, sans-serif`
    }
    function measureTextWidth(text, fontCSS){
      ctx.save(); ctx.font = fontCSS; const w = ctx.measureText(text).width; ctx.restore(); return Math.max(0, Math.floor(w))
    }
    function applyScale(){
      const s = Math.max(4, Math.min(40, parseInt(scaleInput.value,10)||12))
      cvs.style.width = (MAT_W * s) + "px"
      cvs.style.height = (MAT_H * s) + "px"
    }
    function drawGrid(){
      ctx.save(); ctx.strokeStyle = "rgba(255,255,255,0.08)"; ctx.lineWidth = 1
      for(let x=1; x<MAT_W; x++){ ctx.beginPath(); ctx.moveTo(x+0.5, 0); ctx.lineTo(x+0.5, MAT_H); ctx.stroke() }
      for(let y=1; y<MAT_H; y++){ ctx.beginPath(); ctx.moveTo(0, y+0.5); ctx.lineTo(MAT_W, y+0.5); ctx.stroke() }
      ctx.restore()
    }

    function recolorWithGradient(ctx, w, h, preset, reversed, shiftPx){
      const img = ctx.getImageData(0,0,w,h)
      const d = img.data, period = w
      for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
          const i = (y*w + x)*4
          const lum = (d[i]*0.2126 + d[i+1]*0.7152 + d[i+2]*0.0722)
          if(lum >= 128){
            let xx = (x + Math.floor(shiftPx)) % period; if(xx < 0) xx += period
            let t = xx / (period - 1 || 1); if(reversed) t = 1 - t
            const [r,g,b] = gradientPresetColor(t, preset)
            d[i]=r; d[i+1]=g; d[i+2]=b; d[i+3]=255
          } else {
            d[i]=0; d[i+1]=0; d[i+2]=0; d[i+3]=255
          }
        }
      }
      ctx.putImageData(img,0,0)
    }
    function thresholdAndRecolor(ctx, w, h, hexColor){
      const [rC,gC,bC] = hexToRgb(hexColor)
      const img = ctx.getImageData(0,0,w,h), d = img.data
      for(let i=0;i<d.length;i+=4){
        const lum = (d[i]*0.2126 + d[i+1]*0.7152 + d[i+2]*0.0722)
        if(lum >= 128){ d[i]=rC; d[i+1]=gC; d[i+2]=bC; d[i+3]=255 } else { d[i]=0; d[i+1]=0; d[i+2]=0; d[i+3]=255 }
      }
      ctx.putImageData(img,0,0)
    }

    function recalcPreview(){
      shift = 0; gradShift = 0; lastTs = 0
      const text = document.getElementById("text").value
      const fontCSS = currentFontCSS()
      const textW = measureTextWidth(text, fontCSS)
      const disp = document.getElementById("displayMode").value
      maxShift = (disp === "static") ? 0 : (MAT_W + textW)
      applyScale(); drawFrame(0)
    }

    function drawFrame(shiftPx){
      ctx.save(); ctx.imageSmoothingEnabled = false
      ctx.fillStyle="black"; ctx.fillRect(0,0,MAT_W,MAT_H)

      const text = document.getElementById("text").value
      const dir = document.getElementById("direction").value
      const disp = document.getElementById("displayMode").value
      const fontCSS = currentFontCSS()
      const size = parseInt(document.getElementById("fontSize").value,10) || 16
      const isCrisp = !!crispInput.checked
      const isGradient = (colorModeInput.value === "gradient")
      const preset = gradientPresetInput.value
      const reversed = !!gradientReverseInput.checked
      const solidHex = solidColorInput.value
      const emojiOffset = parseInt(emojiBaselineInput.value, 10) || 0
      const emojiPresent = hasEmoji(text)

      ctx.font = fontCSS; ctx.textBaseline = "alphabetic"
      const metrics = ctx.measureText(text)
      const ascent  = metrics.actualBoundingBoxAscent || (size * 0.8)
      const descent = metrics.actualBoundingBoxDescent || (size * 0.2)
      const textH   = Math.ceil(ascent + descent)
      let baselineY = Math.floor((MAT_H - textH) / 2 + ascent)
      if (emojiPresent) baselineY += emojiOffset

      const textW = measureTextWidth(text, fontCSS)
      const centerX = Math.floor((MAT_W - textW)/2)

      if (disp === "static") {
        const x = centerX
        ctx.fillStyle = "#ffffff"; ctx.fillText(text, x, baselineY)
        if(isGradient){ recolorWithGradient(ctx, MAT_W, MAT_H, preset, reversed, gradShift) }
        else if(isCrisp){ thresholdAndRecolor(ctx, MAT_W, MAT_H, solidHex) }
      } else {
        const sPx = Math.floor(shiftPx)
        const useCenterShort = !!centerShortInput.checked && (textW < MAT_W)
        ctx.fillStyle = "#ffffff"
        if(useCenterShort){
          const delta = (dir === "left" ? -sPx : sPx)
          ctx.save(); ctx.beginPath(); ctx.rect(0,0,MAT_W,MAT_H); ctx.clip()
          ctx.fillText(text, centerX + delta, baselineY)
          ctx.restore()
        } else {
          if(dir === "left"){
            ctx.save(); ctx.beginPath(); ctx.rect(0,0,MAT_W,MAT_H); ctx.clip()
            ctx.translate(-sPx,0); ctx.fillText(text, MAT_W, baselineY); ctx.restore()
          } else {
            const canvasW = Math.max(MAT_W, textW + MAT_W)
            ctx.save(); ctx.beginPath(); ctx.rect(0,0,MAT_W,MAT_H); ctx.clip()
            ctx.translate(canvasW - MAT_W - sPx, 0); ctx.fillText(text, 0, baselineY); ctx.restore()
          }
        }
        if(isGradient){ recolorWithGradient(ctx, MAT_W, MAT_H, preset, reversed, gradShift) }
        else if(isCrisp){ thresholdAndRecolor(ctx, MAT_W, MAT_H, solidHex) }
      }

      if(gridInput.checked) drawGrid()
      ctx.restore()
    }

    function animatePreview(ts){
      const disp = document.getElementById("displayMode").value
      if(!lastTs) lastTs = ts
      const dt = (ts - lastTs) / 1000.0; lastTs = ts

      if (disp === "scroll") {
        const speed = Math.max(1, parseFloat(document.getElementById("speed").value)||40)
        shift += speed * dt; if(shift >= maxShift) shift = 0
      }
      const gspd = parseFloat(gradientShiftInput.value)||0
      gradShift = (gradShift + gspd * dt) % MAT_W

      drawFrame(shift)
      animReq = requestAnimationFrame(animatePreview)
    }

    // UI bindings
    document.getElementById("previewPlay").addEventListener("click", () => {
      if(animReq) return;
      recalcPreview();
      animReq = requestAnimationFrame(animatePreview);
    })
    document.getElementById("previewPause").addEventListener("click", () => {
      if(animReq){
        cancelAnimationFrame(animReq);
        animReq=null;
      }
    })
    document.getElementById("previewReset").addEventListener("click", () => {
      if(animReq){
        cancelAnimationFrame(animReq);
        animReq=null;
      }
      recalcPreview();
    })

    ;["text","fontSelect","fontSize","speed","direction","crisp","displayMode","centerShort","colorMode","color","gradientPreset","gradientReverse","gradientShift","emojiBaseline"].forEach(id => {
      const el = document.getElementById(id)
      el.addEventListener("change", () => {
        if(id==="colorMode") updateColorModeUI();
        if(!animReq) recalcPreview();
      })
      el.addEventListener("input",  () => { if(!animReq) recalcPreview() })
    })
    document.getElementById("mode").addEventListener("change", updatePortHelper)

    function nudgeToScrollIfStatic(){
      const sel=document.getElementById("displayMode");
      if (sel.value==="static"){
        sel.value="scroll";
        updateDisplayModeUI();
        if(!animReq) recalcPreview();
      }
    }
    document.getElementById("speed").addEventListener("input", nudgeToScrollIfStatic)
    document.getElementById("speed").addEventListener("change", nudgeToScrollIfStatic)
    document.getElementById("direction").addEventListener("change", nudgeToScrollIfStatic)

    document.getElementById("startBtn").addEventListener("click", async () => {
      if(!animReq){
        recalcPreview();
        animReq = requestAnimationFrame(animatePreview);
      }
      const body = {
        text: document.getElementById("text").value,
        font_path: document.getElementById("fontSelect").value,
        font_size: parseInt(document.getElementById("fontSize").value, 10),

        color_mode: document.getElementById("colorMode").value,
        color: hexToRgb(document.getElementById("color").value),
        gradient_preset: document.getElementById("gradientPreset").value,
        gradient_reverse: !!document.getElementById("gradientReverse").checked,
        gradient_shift_speed: parseFloat(document.getElementById("gradientShift").value)||0,

        speed: parseFloat(document.getElementById("speed").value),
        direction: document.getElementById("direction").value,
        serpentine: document.getElementById("layout").value === "serpentine",
        mode: document.getElementById("mode").value,
        ip: document.getElementById("ip").value,
        port: parseInt(document.getElementById("port").value, 10),
        ddp_channel: parseInt(document.getElementById("ddpChannel").value, 10),
        crisp: !!document.getElementById("crisp").checked,
        display_mode: document.getElementById("displayMode").value,
        center_short: !!document.getElementById("centerShort").checked,

        emoji_baseline_offset: parseInt(document.getElementById("emojiBaseline").value,10) || 0
      }

      try {
        const r = await fetch("/start", {
          method:"POST",
          headers: {"Content-Type":"application/json"},
          body: JSON.stringify(body)
        })
        const j = await r.json()
        if(!j.ok){ alert(j.error || "Failed to start"); }
      } catch (e){
        alert("Failed to reach server: " + e)
      }
    })

    document.getElementById("stopBtn").addEventListener("click", async () => {
      try { await fetch("/stop",{method:"POST"}) } catch(e){}
    })

    async function requestQuote(variant, loadingText) {
      dailyQuoteStatus.textContent = loadingText
      const btns = [dailyQuoteBtn, anotherQuoteBtn]
      if(reloadDailyQuoteBtn) btns.push(reloadDailyQuoteBtn)
      btns.forEach(btn => { if(btn) btn.disabled = true })
      try {
        const url = variant ? `/daily-quote?variant=${variant}` : "/daily-quote"
        const res = await fetch(url)
        if(!res.ok) throw new Error("Quote service unavailable")
        const data = await res.json()
        if(!data.ok) throw new Error(data.error || "Quote service error")
        textInput.value = data.quote
        if(!animReq) recalcPreview()
        if(!variant) {
          lastDailyQuote = data.quote
          if(reloadDailyQuoteBtn) reloadDailyQuoteBtn.disabled = false
        }
        dailyQuoteStatus.textContent = variant ? "Quote loaded" : "Daily quote loaded"
      } catch (err) {
        const message = err && err.message ? err.message : "Failed to load quote"
        dailyQuoteStatus.textContent = message
      } finally {
        btns.forEach(btn => { if(btn) btn.disabled = false })
        setTimeout(() => {
          const current = dailyQuoteStatus.textContent
          if(current === (variant ? "Quote loaded" : "Daily quote loaded") || current === loadingText) {
            dailyQuoteStatus.textContent = ""
          }
        }, 3000)
      }
    }

    dailyQuoteBtn.addEventListener("click", () => requestQuote("", "Fetching daily quote..."))
    anotherQuoteBtn.addEventListener("click", () => requestQuote("alternate", "Fetching alternate quote..."))
    reloadDailyQuoteBtn.addEventListener("click", () => {
      if(lastDailyQuote) {
        textInput.value = lastDailyQuote
        if(!animReq) recalcPreview()
        dailyQuoteStatus.textContent = "Daily quote loaded"
        setTimeout(() => {
          if(dailyQuoteStatus.textContent === "Daily quote loaded")
            dailyQuoteStatus.textContent = ""
        }, 3000)
        return
      }
      requestQuote("", "Fetching daily quote...")
    })

    // init
    updatePortHelper();
    updateDisplayModeUI();
    updateColorModeUI();
    (function ensureArialUnicodeDefault(){
      const sel = document.getElementById("fontSelect"); if (!sel) return;
      const hasSelected = Array.from(sel.options).some(o => o.selected); if (hasSelected) return;
      const target = Array.from(sel.options).find(o => (o.getAttribute("data-fontname") || "").toLowerCase().includes("arial unicode"));
      if (target) target.selected = true;
    })();
    recalcPreview();
  </script>
</body>
</html>
